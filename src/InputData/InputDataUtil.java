package InputData;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;

import com.sun.jna.Native;
import com.sun.jna.ptr.ShortByReference;

import ConvertTool.impl.PROPERTY;

public class InputDataUtil {

	final static byte 深圳 = (byte)0;
	final static byte 上海 = (byte)1;
	// 取得最后交易日的数据
	public static boolean 取得行情数据和最后交易日(List<String> 取得行情, String[] s最后交易日期) {
		byte[] Result = new byte[65535];
		byte[] ErrInfo = new byte[256];
		byte[] Market = { 0, 1 };
		byte[] Zqdm = null;
		byte[] 取得行情数据 = null;
		int 每次取得行情数据= 20;
		//List<String> 取得行情 = new ArrayList();
		// 连接服务器
		if (TdxHqApi209912301.getConnect(PROPERTY.取得IP(), PROPERTY.取得Port(), Result, ErrInfo)) {

			//【交易日】
			// 招商证券北京行情	20190430	20960430
			// 9, 50, 48, 49, 57, 48, 52, 51, 48,
			// 9, 50, 48, 57, 54, 48, 52, 51, 48,
			String s = 取得最后交易日期(Result);
			s最后交易日期[0] = s;
			ShortByReference Count = new ShortByReference();
			//------------------------------------------------------------
			//【实时数据】=最后交易日期
			// 要取得实时数据（因为取不到K线数据，所以只能拿到实时数据）
			//------------------------------------------------------------
			// 0=深圳
			byte[] 深圳股票代码Result = new byte[1024*1024];
			List<String[]> 股票代码ArrayList = new ArrayList();
			if (TdxHqApi209912301.getGetSecurityList(深圳, (short) 0, Count, 深圳股票代码Result, ErrInfo, 股票代码ArrayList)) {

				//List<String[]> 深圳股票代码ArrayList = getArrayListByGBK(深圳股票代码Result);
				// 根据股票的结果数，取得行情数据
				股票代码ArrayList =去除List中重复的数据(股票代码ArrayList);
				List<String> 行情数据 = 取得行情数据(深圳, 股票代码ArrayList, 每次取得行情数据);
				取得行情.addAll(行情数据);

			}

			byte[] 上海股票代码Result = new byte[1024*1024];
			股票代码ArrayList = new ArrayList();
			// 1=上海
			if (TdxHqApi209912301.getGetSecurityList(上海, (short) 0, Count, 上海股票代码Result, ErrInfo, 股票代码ArrayList)) {
				//List<String[]> 上海股票代码ArrayList = getArrayListByGBK(上海股票代码Result);
				// 根据股票的结果数，取得行情数据
				股票代码ArrayList =去除List中重复的数据(股票代码ArrayList);
				List<String> 行情数据 = 取得行情数据(上海, 股票代码ArrayList, 每次取得行情数据);
				取得行情.addAll(行情数据);

			}

		}
		// todayData = 取得Byte数组中的数据(取得行情数据,项目分割,一套分割, 44);
		return true;
	}

	/**
	 *
	 * @param 取得结果Result
	 * @return
	 */
	private static List<String[]> getArrayListByGBK(byte[] 取得结果Result) {
		List<String[]> ResultListByGBK = new ArrayList();
		//------------------------
		// 取出行情数据
		//------------------------
		String s = Native.toString(取得结果Result, "GBK");
		String s1[] = s.split("\n");
		for(int o=1; o<s1.length; o++ ) {
			ResultListByGBK.add(s1[o].split("\t"));
		}
		return ResultListByGBK;
	}

	/**
	 *
	 * @param 取得结果Result
	 * @return
	 */
	static List<String> getStringListByGBK(byte[] 取得结果Result) {
		List<String> ResultListByGBK = new ArrayList();

		if(取得结果Result == null || 取得结果Result.length == 0) {
			return null;
		}
		//------------------------
		// 取出行情数据
		//------------------------
		String s = Native.toString(取得结果Result, "GBK");
		String s1[] = s.split("\n");
		for(int o=1; o<s1.length; o++ ) {
			ResultListByGBK.add(s1[o]);
		}
		return ResultListByGBK;
	}

	public static List<String[]> getStringListByGBK3(byte[] 取得结果Result) {
		List<String[]> ResultListByGBK = new ArrayList();

		if(取得结果Result == null || 取得结果Result.length == 0) {
			return null;
		}
		//------------------------
		// 取出行情数据
		//------------------------
		String s = Native.toString(取得结果Result, "GBK");
		String s1[] = s.split("\n");
		for(int o=1; o<s1.length; o++ ) {
			ResultListByGBK.add(s1[o].split("\t"));
		}
		return ResultListByGBK;
	}
	static Byte 项目分割 = (byte)9;
	static Byte 一套分割 = (byte)10;
	/**
	 *
	 * @param i市场代码
	 * @param 股票代码ArrayList
	 * @param 取得行情数
	 * @return
	 */
	private static List<String> 取得行情数据(int i市场代码, List<String[]> 股票代码ArrayList, int 每次取得行情数据) {

		byte[] Result = new byte[65535];
		byte[] ErrInfo = new byte[256];
		List<String> 取得行情 = new ArrayList<String>();
		ShortByReference Count=new ShortByReference();
		int 股票代码位置=0;
		int 股票名称位置=2;
		int 一套个数 = 8;
		// List<String[]> Byte数组中的数据 = 取得Byte数组中的数据(股票代码ArrayList, 项目分割 , 一套分割 , 一套个数);

		// 每500股取一次行情
		for (int i开始位置 = 0; i开始位置 < 股票代码ArrayList.size(); i开始位置 = i开始位置 + 每次取得行情数据) {

			int[] 每次取得行情数据array = new int[]{每次取得行情数据};

			// 做成这500的股票代码
			String[] 股票代码 = 做成这500的股票信息(股票代码位置, i市场代码, 每次取得行情数据array, i开始位置, 股票代码ArrayList);
			String[] 股票名称 = 做成这500的股票信息(股票名称位置, i市场代码, 每次取得行情数据array, i开始位置, 股票代码ArrayList);
			// 做成这500的市场数据
			byte[] 市场数据 = 做成这500的市场数据(i市场代码, 每次取得行情数据array);
			//------------------------
			// 取得行情数据
			//------------------------
			// 每次做大取得两个
			if( 股票代码[0] == null )break;
			Count.setValue((short)每次取得行情数据array[0]);

			byte[] 行情数据 = TdxHqApi209912301.getGetSecurityQuotes(市场数据, 股票代码, Count, Result, ErrInfo);

			//------------------------
			// 取出行情数据
			//------------------------
//			String s = Native.toString(行情数据, "GBK");
//			String s1[] = s.split("\n");
//			for(int o=1; o<=每次取得行情数据array[0]; o++ ) {
//				取得行情.add(s1[o]);
//			}
			取得行情.addAll(getStringListByGBK2(行情数据, 股票名称));

		}
		return 取得行情;
	}

	private static List<String> getStringListByGBK2(byte[] 行情数据, String[] 股票名称) {
		List<String> ResultListByGBK = new ArrayList();

		if(行情数据 == null || 行情数据.length == 0) {
			return null;
		}

		/* 行情数据=
		 * [-54, -48, -77, -95, 9, -76, -6, -62, -21, 9, -69, -18, -44, -66, -74, -56, 9, -49, -42, -68, -37, 9, -41, -14, -54, -43, 9, -65, -86, -59, -52, 9, -41, -18, -72, -33, 9, -41, -18, -75, -51, 9, -54, -79, -68, -28, 9, -79, -93, -63, -12, 9, -41, -36, -63, -65, 9, -49, -42, -63, -65, 9, -41, -36, -67, -16, -74, -18, 9, -60, -38, -59, -52, 9, -51, -30, -59, -52, 9, -79, -93, -63, -12, 9, -79, -93, -63, -12, 9, -62, -14, -46, -69, -68, -37, 9, -62, -12, -46, -69, -68, -37, 9, -62, -14, -46, -69, -63, -65, 9, -62, -12, -46, -69, -63, -65, 9, -62, -14, -74, -2, -68, -37, 9, -62, -12, -74,
		 *
		 */
		//------------------------
		// 取出行情数据
		//------------------------
		String s = Native.toString(行情数据, "GBK");
		/* s=
		 市场	代码	活跃度	现价	昨收	开盘	最高	最低	时间	保留	总量	现量	总金额	内盘	外盘	保留	保留	买一价	卖一价	买一量	卖一量	买二价	卖二价	买二量	卖二量	买三价	卖三价	买三量	卖三量	买四价	卖四价	买四量	卖四量	买五价	卖五价	买五量	卖五量	保留	保留	保留	保留	保留	涨速	活跃度
		0	000811	2019	9.530000	9.430000	9.370000	9.550000	9.360000	14133848	-953	64698	85	61162384.000000	34216	30483	0	3682	9.510000	9.530000	57	627	9.500000	9.540000	95	1096	9.490000	9.550000	588	697	9.480000	9.560000	397	326	9.470000	9.570000	483	231	5132	0	23	15	-28	0.110000	2019
		0	300617	2064	39.110000	37.070000	37.420000	39.530000	36.590000	14130890	0	30811	6	117164816.000000	13717	17094	-4	4715	39.100000	39.110000	9	6	39.040000	39.150000	2	2	39.000000	39.180000	7	1	38.930000	39.190000	11	7	38.880000	39.200000	2	23	1805	1	-138	-427	-148	-0.140000	2064
		0	300943	1391	21.980000	22.180000	22.400000	22.400000	21.800000	14132603	0	17430	31	38408692.000000	10724	6707	0	3763	21.970000	21.980000	8	29	21.960000	21.990000	270	36	21.920000	22.000000	1	5	21.910000	22.010000	49	40	21.900000	22.020000	67	49	4300	0	81	104	-45	0.270000	1391
		0	000685	1698	7.440000	7.370000	7.380000	7.470000	7.370000	14133457	-744	57942	1	43019832.000000	26381	31561	0	797	7.440000	7.450000	119	764	7.430000	7.460000	453	1094	7.420000	7.470000	506	1523	7.410000	7.480000	829	889	7.400000	7.490000	847	1192	1421	1	-11	-19	-4	0.130000	1698
		0	300024	1877	7.870000	7.800000	7.790000	7.930000	7.790000	14133714	0	69242	1	54493996.000000	33887	35356	0	1262	7.870000	7.880000	301	658	7.860000	7.890000	1911	256	7.850000	7.900000	739	1138	7.840000	7.910000	264	194	7.830000	7.920000	336	628	6157	0	-5	5	-18	0.000000	1877
		0	301062	881	11.120000	11.280000	11.280000	11.350000	11.100000	14132189	0	13497	3	15103340.000000	7744	5754	0	372	11.120000	11.130000	30	57	11.110000	11.140000	61	3	11.100000	11.150000	451	120	11.090000	11.180000	93	15	11.080000	11.190000	86	12	5069	1	42	-76	55	0.000000	881
		0	300672	3325	74.200000	75.650000	75.650000	75.650000	72.570000	14127381	0	73216	10	541264704.000000	39850	33366	2	93125	74.170000	74.200000	4	6	74.160000	74.220000	28	64	74.150000	74.230000	3	15	74.140000	74.240000	28	6	74.130000	74.260000	36	9	268	1	920	-1456	837	0.050000	3325
		0	399231	3880	1402.020000	1399.580000	1392.180000	1417.470000	1384.750000	13994599	0	6242635	4339	6542227456.000000	0	0	660228	-140202	1402.020000	1402.020000	0	0	1402.020000	1402.020000	0	0	1402.020000	1402.020000	0	0	1402.020000	1402.020000	0	0	1402.020000	1402.020000	0	0	2	0	-140202	-140202	-140202	0.200000	0
		0	001319	1040	37.970000	34.520000	37.970000	37.970000	37.970000	14130704	-3797	17239	1	65459292.000000	15666	1574	0	119531	37.970000	0.000000	108670	0	37.960000	0.000000	18	0	37.950000	0.000000	8	0	37.940000	0.000000	2	0	37.930000	0.000000	4	0	4749	0	254	-31	-345	0.000000	1040
		0	000735	1808	5.910000	5.880000	5.870000	5.940000	5.860000	14134210	-591	83207	2	49130756.000000	39552	43656	0	2788	5.900000	5.910000	2128	987	5.890000	5.920000	2096	2765	5.880000	5.930000	2076	1358	5.870000	5.940000	1018	1259	5.860000	5.950000	1402	1727	5836	1	-8	-16	3	0.000000	1808
		0	300903	951	23.140000	23.220000	23.520000	23.650000	23.020000	14132487	0	14928	20	34793252.000000	9145	5783	1	2517	23.130000	23.140000	51	22	23.120000	23.150000	20	13	23.110000	23.160000	18	20	23.100000	23.180000	18	10	23.090000	23.190000	5	20	844	1	-70	-68	32	0.260000	951
		0	200771	196	14.230000	13.710000	13.910000	14.280000	13.780000	14112178	-1423	3278	1	4613152.000000	1112	2167	0	1350	14.220000	14.230000	431	1	14.200000	14.250000	69	64	14.180000	14.260000	7	120	14.170000	14.280000	10	7	14.150000	14.290000	10	75	4364	1	15	-155	-20	0.000000	196
		0	002683	1867	21.170000	20.950000	20.960000	21.550000	20.960000	14132384	-2117	34355	1	73083184.000000	18636	15719	0	1153	21.170000	21.180000	10	8	21.160000	21.200000	1	11	21.150000	21.210000	24	11	21.140000	21.220000	23	6	21.130000	21.230000	18	42	13	0	-19	5	-44	0.140000	1867
		0	300317	2138	5.600000	5.530000	5.630000	5.700000	5.500000	14134241	0	129794	7	72414224.000000	63452	66342	0	11688	5.590000	5.600000	286	441	5.580000	5.610000	225	1028	5.570000	5.620000	413	1120	5.560000	5.630000	178	1275	5.550000	5.640000	449	663	460	0	16	21	-27	0.180000	2138
		0	000889	1900	2.160000	2.100000	2.080000	2.190000	2.080000	14134285	-216	354084	22	75390488.000000	179173	174912	0	12530	2.160000	2.170000	9267	3263	2.150000	2.180000	6869	10530	2.140000	2.190000	4996	9790	2.130000	2.200000	3409	17126	2.120000	2.210000	2617	33302	5645	0	6	8	-12	-0.450000	1900
		0	002079	2730	9.970000	9.870000	9.880000	10.080000	9.780000	14133804	-997	133613	1	132243432.000000	70199	63414	0	9099	9.960000	9.970000	308	480	9.950000	9.980000	284	364	9.940000	9.990000	284	1188	9.930000	10.000000	292	1391	9.920000	10.010000	176	1069	2636	1	18	-81	14	0.200000	2730
		0	002785	1609	26.730000	27.070000	27.210000	27.400000	26.650000	14131528	-2673	26873	3	72432544.000000	14248	12625	-1	10911	26.730000	26.740000	91	22	26.720000	26.750000	79	130	26.710000	26.770000	55	96	26.700000	26.800000	12	22	26.690000	26.820000	2	18	13	0	54	233	-50	0.190000	1609
		0	000012	3363	6.110000	6.090000	6.110000	6.140000	6.030000	14134190	-611	511325	108	311387232.000000	281945	229381	0	28155	6.110000	6.120000	232	6630	6.100000	6.130000	3513	4297	6.090000	6.140000	3080	2056	6.080000	6.150000	3883	4375	6.070000	6.160000	3627	2072	4621	1	15	-52	16	0.160000	3363
		0	002689	1059	3.010000	2.990000	3.010000	3.060000	2.980000	14132100	-301	89703	1	27053868.000000	50768	38936	0	2420	3.000000	3.010000	2099	1999	2.990000	3.020000	3053	4849	2.980000	3.030000	2566	2709	2.970000	3.040000	3968	2771	2.960000	3.050000	2185	2885	5772	1	0	-11	0	0.330000	1059
		0	000677	1627	3.070000	3.010000	3.010000	3.110000	3.000000	14134494	-307	108579	44	33199506.000000	39170	69409	0	346	3.070000	3.080000	3449	144	3.060000	3.090000	5621	2072	3.050000	3.100000	2070	4041	3.040000	3.110000	1349	2284	3.030000	3.120000	1860	1149	13	1	-3	-17	-3	-0.310000	1627
		 */
		String s1[] = s.split("\n");
		for(int o=1; o<s1.length; o++ ) {
			// 绑定股票与行情信息
			// [0	000811	2019	9.530000	9.430000	9.370000	9.550000	9.360000	14133848	-953	64698	85	61162384.000000	34216	30483	0	3682	9.510000	9.530000	57	627	9.500000	9.540000	95	1096	9.490000	9.550000	588	697	9.480000	9.560000	397	326	9.470000	9.570000	483	231	5132	0	23	15	-28	0.110000	2019	冰轮环境]
			ResultListByGBK.add(s1[o].concat("\t").concat(股票名称[o-1]));
		}
		return ResultListByGBK;
	}

	/**
	 *
	 * @param i市场代码
	 * @param 取得行情数
	 * @param i开始位置
	 * @param 股票代码Result
	 * @return
	 */
	private static String[] 做成这500的股票信息(int 取得位置, int i市场代码, int[] 取得行情数, int i开始位置, List<String[]> 股票代码Result) {
		// 这里记述的是怎么解析
		// 基本的思路就是
		// 先将【股票代码Result】分解成结构体。
		// 然后从结构体中取得【股票代码】
		int n = 取得行情数[0];
		String[] 股票代码 = new String[n];

		for(int i=i开始位置, j = 0 ; j < n; i++) {
			// 如果超界了，就只好有多少取多少了。
			if(i >= 股票代码Result.size()) {
				if(j == 0) {break;}
				股票代码 = getStrFromStrArray(股票代码, 0, j-1);
				取得行情数[0] = j;
				break;
			}
			if(股票代码Result.get(i)[0].length() != 6) continue;
			if(i市场代码 ==1) {
				if((股票代码Result.get(i)[0].charAt(0) == '6'|| 股票代码Result.get(i)[0].charAt(0) == '0'|| 股票代码Result.get(i)[0] == "1A0001")) {

				}else {
					continue;
				}
			}
			if(i市场代码 ==0) {
				if((股票代码Result.get(i)[0].charAt(0) == '1')) {
					continue;
				}else {

				}
			}
			股票代码[j] = 股票代码Result.get(i)[取得位置];
			j++;
		}

		return 股票代码;

	}

	private static String[] getStrFromStrArray(String[] 股票代码, int i开, int i闭) {
		// 第一次 i闭=0， i开=10
		if((i闭 - i开) == 0) {
			return new String[] {股票代码[0]};
		}
		String b[] = new String[i闭 - i开];

		for(int i=0,j=i开; i< i闭 - i开 ; i++,j++) {
			b[i] = 股票代码[j];
		}
		return b;
	}

	/**
	 * 	static Byte 项目分割 = (byte)9;
	 * 	static Byte 一套分割 = (byte)10;
	 */
	private static List<String[]> 取得Byte数组中的数据(byte[] 股票代码Result, Byte 项目分割, Byte 一套分割, int 一套个数) {
		long i开 = 0;
		long i闭 = 0;
		int i一套数据中的计数器 = 0;
		long iSize = 股票代码Result.length;
		List<String[]> sList = new ArrayList<String[]>();
		String[] 一套数据 = new String[一套个数];

		// 循环取得【股票代码Result】中每一个byte
		for(byte b: 股票代码Result) {


			if(b != 项目分割  && b != 一套分割) {
				//---------------------------------
				// 如果还没有碰到（项目分割/一套分割）
				// 就继续计数
				//---------------------------------

			}else {
				//---------------------------------
				// 如果碰到了其中一个（项目分割/一套分割）
				// 那么这个数据就形成了。
				//---------------------------------
				if(i一套数据中的计数器 == 一套个数) {
					sList.add(一套数据);
					一套数据 = new String[一套个数];
					i一套数据中的计数器 = 0;
				}
				一套数据[i一套数据中的计数器] = getGB2312StrFromByte(股票代码Result,i开,i闭);
				if(i一套数据中的计数器 ==42 && sList.size()==1) {
					i一套数据中的计数器 =42;
				}
				if(i一套数据中的计数器 ==41 && sList.size()==2) {
					i一套数据中的计数器 =41;
				}
			}

			if(b == 项目分割){
				// 需要移动i开的位置
				i开 = i闭 + 1;
				i一套数据中的计数器++;
			}

			// 而且当你碰到的是【一套分割】时
			if(b == 一套分割) {
				//---------------------------------
				// 需要移动i开的位置
				// 并且将取到的数据计入到sList中
				// 将【i一套数据中的计数器】归零
				//---------------------------------
				i开 = i闭 + 1;
				sList.add(一套数据);
				一套数据 = new String[一套个数];
				i一套数据中的计数器 = 0;
			}
			i闭++;
		}
		// 说明最后一位不是【一套分割】的标志位就结束了。
		if(i一套数据中的计数器 != 0) {
			一套数据[i一套数据中的计数器] = getGB2312StrFromByte(股票代码Result,i开,i闭);
			sList.add(一套数据);
			i一套数据中的计数器 = 0;
		}

		return sList;
	}

	private static String getGB2312StrFromByte(byte[] 股票代码Result, long i开, long i闭) {
		// 第一次 i闭=0， i开=10

		byte b[] = new byte[(int) (i闭 - i开)];

		for(long i=0,j=i开; i< i闭 - i开 ; i++,j++) {

			// 如果这个数值是零，且以后的，都为零时。
			// 舍掉后面的数据。
			if(股票代码Result[(int) j] == 0) {
				if(isBlankFromByte(股票代码Result, (int) j, 股票代码Result.length)) {

					b[(int) i] = 股票代码Result[(int) j];
					b = cutByteFromByte(b, 0, (int) (j-i开));
					break;
				}
			}
			b[(int) i] = 股票代码Result[(int) j];
		}
		try {
			return new String(b, "gb2312");
		} catch (UnsupportedEncodingException e) {
			e.printStackTrace();
		}
		return null;
	}

//	/**
//	 *
//	 * @param 股票代码Result
//	 * @param i开
//	 * @param i闭
//	 * @return
//	 */
//	private static byte[] removeBlankFromByte(byte[] 股票代码Result, long i开, long i闭) {
//		byte b[] = new byte[(int) (i闭 - i开)];
//		for(long i=0,j=i开; i< i闭 - i开 ; i++,j++) {
//
//			// 如果这个数值是零，且以后的，都为零时。
//			// 舍掉后面的数据。
//			if(股票代码Result[(int) j] == 0) {
//				if(isBlankFromByte(股票代码Result, (int) j, 股票代码Result.length)) {
//
//					b[(int) i] = 股票代码Result[(int) j]; //
//					b = cutByteFromByte(b, 0, (int) (j-i开) + 1);
//					b[(int) j] = (byte)10;
//					break;
//				}
//			}
//			b[(int) i] = 股票代码Result[(int) j];
//		}
//		return b;
//	}
	private static boolean isBlankFromByte(byte[] 股票代码Result, int i开, int i闭) {

		int iResult=0;
		for(int i=0,j=i开; i< i闭 - i开 ; i++,j++) {
			iResult += 股票代码Result[j];
		}
		return iResult == 0;

	}

	public static byte[] cutByteFromByte(byte[] 股票代码Result, int i开, int i闭) {
		if((i闭 - i开)>=股票代码Result.length) {
			return 股票代码Result;
		}
		// 第一次 i闭=0， i开=10
		if((i闭 - i开) == 0) {
			return new byte[] {股票代码Result[0]};
		}
		byte b[] = new byte[i闭 - i开];

		for(int i=0,j=i开; i< i闭 - i开 ; i++,j++) {
			if(i>= i闭 - i开) {
				break;
			}

			b[i] = 股票代码Result[j];
		}
		return b;
	}

	/**
	 * 根据每次取得行情数据array
	 * 自动生成【市场数据】的数据
	 * @param i市场代码
	 * @param 每次取得行情数据array
	 * @return
	 */
	private static byte[] 做成这500的市场数据(int i市场代码, int[] 每次取得行情数据array) {

		int n = 每次取得行情数据array[0];
		byte[] 市场数据 = new byte[n];
		for (int i = 0; i < n; i++) {
			市场数据[i] = (byte) i市场代码;
		}
		return 市场数据;
	}

	private static String 取得最后交易日期(byte[] result) {

		// 每一行用换行符(\r)分割
		// 每个数据用的是tab(\t)分割

			  // 先将，二进制result转成字符串        // 例、String s = Native.toString(Result, "GBK");
			  // 再用换行符将上述字符串按行分割                	// 例、String[] 所有行 = s.split("\r");
			  // 最后把第二行的第二个字符串提取、并返回        	// 例、String 第二行 = 所有行[1];
			               									// 例、String[] 第二行所有字符串 = 第二行.split("\t");
			                                                //     String 第二行第二个字符= 第二行所有字符串[1];
			                                                //     return 第二行第二个字符
			  /*
			   服务器名称 最后交易日期 接口过期日期
			   招商证券北京行情 20190909 20991230
			   */
		  String s = Native.toString(result, "GBK");
		  /*
		   * 服务器名称\t最后交易日期\t接口过期日期\r招商证券北京行情\t20190909\t20991230
		   */
		  String[] 所有行 = s.split("\n");  	// 换行符=\r
		  String 第二行 = 所有行[1];   		// 0,1
		  String[] 第二行所有字符串 = 第二行.split("\t");
		  String 第二行第二个字符= 第二行所有字符串[1];
		  return 第二行第二个字符;

		//  // 取得最后的18个byte！
		//  List<String[]> sList =取得Byte数组中的数据(result,项目分割,一套分割,3 );
		//  return sList.get(1)[1];
	}

	/**
	 * 去除List中重复的数据
	 * @param list
	 * @return
	 */
	public static List 去除List中重复的数据(List list) {
		/**
		 * HashSet简单的理解就是HashSet对象中不能存储相同的数据，存储数据时是无须的。
		 * 但是HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不同）
		 * 是按照哈希值来存的所以取数据也是按照哈希值取得。
		 * 存储是无序的这就和C++里的Set就不一样了C++里面的Set是有序的我认为这是在使用时候的主要区别
		 */
		HashSet h = new HashSet(list);
		list.clear();
		list.addAll(h);
		return list;
		}
}
